# Аккорды

Данный модуль позволяет вам задавать аккорды любой длины, причём в отличие от стандартной фичи [combos](https://docs.qmk.fm/#/feature_combo) в QMK, данный модуль способен посылать любые кейкоды. Причём данные аккорды способны работать не только в качестве "нажал-отпустил", а качестве зажимаемых клавиш, будь то переключение слоя или модификатор.

Аккорд срабатывает в следующих случаях:
* Если вы зажимаете клавиши для аккорда более 100 миллисекунд, то считается что вы больше не нажмёте клавиш для следующего аккорда, и кейкод текущего аккорда нажимается. Например, можно задать на клавише `CMB_001` аккорд из одной этой клавиши, который при срабатанывании будет нажимать `KC_BSPC` (Backspace), таким образом если вы зажмёте клавишу `CMB_001`, то у вас сначала будет ожидание 100мс, затем нажмётся клавиша Backspace, и начнёт стираться текст. То есть клавиши для аккордов можно свободно использовать даже для клавиш, которые предполагается зажимать, а не только нажать и отпускать.
* Если вы во время зажатия аккорда нажимаете другую клавишу, то считается что вы больше не нажмёте клавиш для следующего аккорда, и кейкод текущего аккорда нажимается.

Если вы хотите более подробно понять как работает обработка аккордов, или хотите модифицировать код, смотрите секцию [принцип работы](#принцип-работы).

Советую вам не бояться нажимать две клавиши одним пальцем, и помещать на такие нажатия аккорды.

# Как использовать?

Приготовьтесь, использовать довольно сложно, потому что данный модуль построен на костылях и хаках (если придумаете как сделать иначе - делайте MR!).

Последовательность действий будет описана так, чтобы вы модифицировали свой файл `keymap.c` сверху-вниз.

## Задать характеристики

В `config.h` нужно прописать задание следующих переменных, модифицируя их под свои нужды:

* `#define COMBO_KEYS_COUNT 5` - количество используемых клавиш для аккордов, для данной опции у вас в итоге получатся клавиши `CMB_000`, `CMB_001`, ... , `CMB_004`.
* `#define COMBO_MAX_SIZE 3` - максимальное количество одновременно зажимаемых клавиш для одного аккорда, больше этого размера аккорд задавать нельзя. При больших значениях потребляет больше памяти.
* `#define COMBO_STACK_MAX_SIZE 3` - максимальное количество одновременно зажимаемых аккордов. То есть, например, у вас есть аккорд для получения шифта, вы его зажимаете, затем вы нажимаете другой аккорд один раз, это значит что максимально у вас было 2 одновременно зажатых аккорда. 3 должно хватить для всех целей.
* `#define COMBO_WAIT_TIME 100` - время в миллисекундах в течении которого ждётся что все клавиши текущего аккорда будут нажаты. Если это время истекло, и текущую комбинацию нажатых клавиш можно трактовать как аккорд, то именно эта комбинация и пошлётся.

## Подключение кода

В своём файле `keymap.c` в самом верху подключаем файл `combo/code.c`:
```c
#include "combo/code.c"
```

## Записать аккорды

Далее надо записать аккорды и зажимаемые для них клавиши. Записывается при помощи макроса `CHORD`, где первым аргументом передаётся кейкод, который будет нажат (там можно задать даже кастомный кейкод, и переключение слоя), затем нужно указать клавиши `CMB_***` одновременное зажатие которых будет посылать зажатие данного аккорда.

```c
const ComboWithKeycode combos[] = {
  // Left Index
  CHORD(MO(4),         CMB_000),
  CHORD(MY_KEY,        CMB_001),
  CHORD(LGUI(S(KC_A)), CMB_000, CMB_001),
  // ...
 };
const uint8_t combos_size = sizeof(combos)/sizeof(ComboWithKeycode);
```

Здесь при единичном зажатии клавиши `CMB_000` будет включаться 4 слой, а при нажатии этой клавиши одновременно с `CMB_001` будет нажиматься `Win+Shift+A`.

## Поместить аккорды на вашу раскладку

Используйте кейкоды `CMB_000`-`CMB_XXX` (зависит сколько вы задали их в начале файла).

```c
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    //---------------------------------------------------------------------------
  [0] = MY_layout(
    // ...
    XXXXXXX,    XXXXXXX,  XXXXXXX,  CMB_003,  CMB_004,
    CMB_002,
    CMB_000,    CMB_001,  KC_ENT,
    // ...
  ),
  // ...
```

## Вызов модуля для каждой клавиши

В функции `process_record_user` в самом начале, перед всеми проверками, добавляем код обработки аккорда:
```c
bool process_record_user(uint16_t key, keyrecord_t *record) {
  if (combo_enabled && !combo_process(keycode, record))
    return false;

  // ...
}
```

Затем нужно определить функцию `matrix_scan_user`, если она у вас ещё не определена, и вызывать функцию `user_timer`, а в этой функции вызывать `combo_user_timer();`:
```c
void user_timer(void) {
  combo_user_timer();
}

void matrix_scan_user(void) {
  user_timer();
}
```

**Объяснение:** функция `matrix_scan_user` вызывается примерно каждые 2 миллисекунды, она сканирует матрицу. Значит её вполне можно использовать для отслеживания собственных таймеров. Поэтому мы вызываем из неё функцию `user_timer`, которая лучше говорит о наших намерениях, чем `matrx_scan_user`. А уже в функции `user_timer` мы вызываем обработку случая когда мы слишком долго держим аккорд.

# Модифицировать код qmk

```diff
diff --git a/quantum/keymap_common.c b/quantum/keymap_common.c
index 570d4798d..a3536ce16 100644
--- a/quantum/keymap_common.c
+++ b/quantum/keymap_common.c
@@ -179,7 +179,11 @@ __attribute__((weak)) void action_function(keyrecord_t *record, uint8_t id, uint
 // translates key to keycode
 __attribute__((weak)) uint16_t keymap_key_to_keycode(uint8_t layer, keypos_t key) {
     // Read entire word (16bits)
-    return pgm_read_word(&keymaps[(layer)][(key.row)][(key.col)]);
+    if (key.use_custom_keycode) {
+        return key.custom_keycode;
+    } else {
+        return pgm_read_word(&keymaps[(layer)][(key.row)][(key.col)]);
+    }
 }
 
 // translates function id to action
diff --git a/tmk_core/common/keyboard.h b/tmk_core/common/keyboard.h
index ff7736718..59ff1c893 100644
--- a/tmk_core/common/keyboard.h
+++ b/tmk_core/common/keyboard.h
@@ -29,6 +29,8 @@ extern "C" {
 typedef struct {
     uint8_t col;
     uint8_t row;
+    bool use_custom_keycode;
+    uint16_t custom_keycode;
 } keypos_t;
 
 /* key event */
```

# Принцип работы

![](dka.png)

Здесь показано как работает обработка аккордов. Оранжевые прямоугольники показывают условиях перехода; белые показывают ждущие состояния; зелёные показывают действия. В белых прямоугольниках подписан номер состояния, которое хранится в `combo->state`, а в оранжевых подписана буква перехода, которую можно найти в коде по использованию макроса `TRANSITION_DEBUG()`.

Данный конечный автомат показывает обработку для одного аккорда, находящегося в стэке. Порядок обработки следующий:
* Сначала обрабатываем все аккорды в стэке согласно этому ДКА, если хотя бы один сработал, завершаем всю обработку.
* Если ни один не сработал, то обрабатываем текущую клавишу синим прямоугольником.

Таким образом мы можем добавлять новые аккорды в стэк если они не добавляют ничего к уже зажатым, и можем добавлять к зажатым ещё клавиш, если в итоге можно что-то нажать.
